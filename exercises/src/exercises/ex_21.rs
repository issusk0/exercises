



pub fn ex_21(packet: &[u8]){
    //si es ipv4 se parte desde 0 sino desde el 14
    let start_index = check_header(packet);
    

    if start_index > 2500 {
        println!("error en el paquete");
    }
    
    is_ipv4(packet, start_index);

}



pub fn data() -> Vec<u8>{
let packet: Vec<u8> = vec![
    // ===============================
    // Ethernet II
    // ===============================
    0x00,0x11,0x22,0x33,0x44,0x55,
    0x66,0x77,0x88,0x99,0xaa,0xbb,
    0x08,0x00,

    // ===============================
    // IPv4
    // ===============================
    0x45,0x00,
    0x03,0x20,
    0x12,0x34,
    0x40,0x00,
    0x40,
    0x06,
    0x00,0x00,
    0x8d,0x7a,0xd8,0x3c,      // src 141.122.216.60
    0xc0,0xa8,0x01,0x64,      // dst 192.168.1.100

    // ===============================
    // TCP
    // ===============================
    0x00,0x50,                // src port 80
    0xd4,0x31,                // dst port 54321
    0x00,0x00,0x00,0x02,
    0x00,0x00,0x00,0x02,
    0x50,
    0x18,
    0x72,0x10,
    0x00,0x00,
    0x00,0x00,

    // ===============================
    // HTTP STATUS LINE
    // ===============================
    0x48,0x54,0x54,0x50,0x2f,0x31,0x2e,0x31, // HTTP/1.1
    0x20,0x32,0x30,0x30,0x20,0x4f,0x4b,     // 200 OK
    0x0d,0x0a,

    // Date
    0x44,0x61,0x74,0x65,0x3a,0x20,
    0x4d,0x6f,0x6e,0x2c,0x20,
    0x32,0x32,0x20,0x44,0x65,0x63,0x20,
    0x32,0x30,0x32,0x35,0x20,
    0x31,0x30,0x3a,0x30,0x30,0x3a,0x30,0x30,
    0x20,0x47,0x4d,0x54,
    0x0d,0x0a,

    // Server
    0x53,0x65,0x72,0x76,0x65,0x72,0x3a,0x20,
    0x41,0x70,0x61,0x63,0x68,0x65,0x2f,0x32,0x2e,0x34,0x2e,0x31,
    0x20,0x28,0x55,0x6e,0x69,0x78,0x29,
    0x0d,0x0a,

    // Content-Type
    0x43,0x6f,0x6e,0x74,0x65,0x6e,0x74,0x2d,0x54,0x79,0x70,0x65,0x3a,0x20,
    0x74,0x65,0x78,0x74,0x2f,0x68,0x74,0x6d,0x6c,0x3b,0x20,
    0x63,0x68,0x61,0x72,0x73,0x65,0x74,0x3d,0x55,0x54,0x46,0x2d,0x38,
    0x0d,0x0a,

    // Content-Length
    0x43,0x6f,0x6e,0x74,0x65,0x6e,0x74,0x2d,0x4c,0x65,0x6e,0x67,0x74,0x68,0x3a,0x20,
    0x31,0x32,0x33,0x34,
    0x0d,0x0a,

    // Connection
    0x43,0x6f,0x6e,0x6e,0x65,0x63,0x74,0x69,0x6f,0x6e,0x3a,0x20,
    0x6b,0x65,0x65,0x70,0x2d,0x61,0x6c,0x69,0x76,0x65,
    0x0d,0x0a,

    // END HEADERS
    0x0d,0x0a,

    // ===============================
    // HTML BODY (tipo Django DEBUG)
    // ===============================
    0x3c,0x21,0x44,0x4f,0x43,0x54,0x59,0x50,0x45,0x20,
    0x68,0x74,0x6d,0x6c,0x3e,
    0x3c,0x68,0x74,0x6d,0x6c,0x3e,
    0x3c,0x68,0x65,0x61,0x64,0x3e,
    0x3c,0x74,0x69,0x74,0x6c,0x65,0x3e,
    0x44,0x65,0x62,0x75,0x67,0x20,0x50,0x61,0x67,0x65,
    0x3c,0x2f,0x74,0x69,0x74,0x6c,0x65,0x3e,
    0x3c,0x2f,0x68,0x65,0x61,0x64,0x3e,
    0x3c,0x62,0x6f,0x64,0x79,0x3e,
    0x3c,0x68,0x31,0x3e,
    0x44,0x6a,0x61,0x6e,0x67,0x6f,0x20,0x44,0x65,0x62,0x75,0x67,
    0x3c,0x2f,0x68,0x31,0x3e,
    0x3c,0x70,0x3e,
    0x54,0x72,0x61,0x63,0x65,0x62,0x61,0x63,0x6b,0x20,0x28,
    0x6d,0x6f,0x73,0x74,0x20,0x72,0x65,0x63,0x65,0x6e,0x74,
    0x20,0x63,0x61,0x6c,0x6c,0x20,0x6c,0x61,0x73,0x74,0x29,
    0x3c,0x2f,0x70,0x3e,
    0x3c,0x2f,0x62,0x6f,0x64,0x79,0x3e,
    0x3c,0x2f,0x68,0x74,0x6d,0x6c,0x3e,
];



    packet

}



fn check_header(packet: &[u8]) -> usize{
    //tiene tcp pero no tampoco cumple con el minimo para ser http, es tcp invalido
    if packet.len() <20{return 2000;}
    

    //para ver si es ipv4
    

    if packet[0] >> 4 == 4{
        return 0;

    }

    //para checkar si es ethernet
    if packet.len()>=34{
         let byte_1 = packet[12];
         let byte_2 = packet[13];
         let ether_type = ((byte_1 as u16) << 8)|(byte_2 as u16);
         let version_after_eth = packet[14] >> 4;
         if ether_type == 0x0800 && version_after_eth == 4{
            return 14
         }

    }
    
    //no se pudo concretar ni eth o ip
    return 2000

}
fn is_ipv4(packet: &[u8],index: usize){
    let ihl = packet[index] & 0x0F;
    let ip_header_len = (ihl as usize) * 4;


    let tcp = &packet[index + ip_header_len..];
    let data_offset = tcp[12] >> 4;
    let tcp_header_len = (data_offset as usize) * 4;

    let http = &tcp[tcp_header_len..];
    let s = std::str::from_utf8(http).unwrap();

    println!("{}", s);


}
